import mongoose from "mongoose";

const componentSchema = new mongoose.Schema({
  componentId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "Product",
    required: true,
  },
  componentName: { type: String, required: true },
  requiredQuantity: { type: Number, required: true },
  availableQuantity: { type: Number, default: 0 },
  reservedQuantity: { type: Number, default: 0 },
  status: {
    type: String,
    enum: ["Available", "Partial", "Unavailable"],
    default: "Unavailable",
  },
  unitCost: { type: Number, default: 0 },
});

const productionOrderSchema = new mongoose.Schema(
  {
    companyId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Company",
      required: true,
    },
    orderNumber: {
      type: String,
      required: false, // Will be auto-generated by pre-save hook
      unique: true,
    },
    productId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Product",
      required: true,
    },
    productName: { type: String, required: true },
    quantity: {
      type: Number,
      required: true,
      min: 1,
    },
    bomId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "productTree",
      required: false,
    },
    status: {
      type: String,
      enum: ["Pending", "In Progress", "Completed", "Cancelled", "On Hold"],
      default: "Pending",
    },
    priority: {
      type: String,
      enum: ["low", "medium", "high", "urgent"],
      default: "medium",
    },
    startDate: { type: Date },
    dueDate: { type: Date, required: true },
    completedDate: { type: Date },
    assignedTo: [
      {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Employee",
      },
    ],
    departmentId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Department",
      required: false,
    },
    customerOrderId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "CustomerOrder",
      required: false,
    },
    components: [componentSchema],
    actualCost: { type: Number, default: 0 },
    estimatedCost: { type: Number, default: 0 },
    notes: { type: String },
    inventoryReserved: { type: Boolean, default: false },
    inventoryReservedAt: { type: Date },
    missingComponents: [
      {
        componentId: { type: mongoose.Schema.Types.ObjectId, ref: "Product" },
        componentName: { type: String },
        required: { type: Number },
        available: { type: Number },
        missing: { type: Number },
      },
    ],
    // קישור לתנועות מלאי
    inventoryMovements: [
      {
        movementId: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "InventoryMovement",
        },
        componentId: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "Product",
        },
        componentName: { type: String },
        quantity: { type: Number },
        movementDate: { type: Date },
        movementType: {
          type: String,
          enum: ["Component Withdrawal", "Product Completion", "Return"],
        },
      },
    ],
  },
  { timestamps: true }
);

// Generate order number before save
productionOrderSchema.pre("save", async function (next) {
  if (!this.orderNumber) {
    try {
      // Use this.constructor to avoid model registration issues
      const ProductionOrderModel = this.constructor;
      // Get session from document options if available
      const session = this.$session();
      const countQuery = ProductionOrderModel.countDocuments({
        companyId: this.companyId,
      });
      // Apply session if available
      if (session) {
        countQuery.session(session);
      }
      const count = await countQuery;
      this.orderNumber = `PROD-${String(count + 1).padStart(6, "0")}`;
    } catch (error) {
      // If model doesn't exist yet or error occurs, use timestamp
      console.error("Error generating production order number:", error);
      this.orderNumber = `PROD-${Date.now()}`;
    }
  }
  next();
});

const ProductionOrder =
  mongoose.models.ProductionOrder ||
  mongoose.model("ProductionOrder", productionOrderSchema);

export default ProductionOrder;

